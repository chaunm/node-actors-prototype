Actor System
===============

## Actors
### Overview
Actors are programming concepts to model entities communicate via messages.
+ Can be implemented in any programming language
+ Have their own mailboxes which are authorized topics on a message broker.
+ Can be featured by a GUID

### Mailboxes
A mailbox (a topic) can be configured to subscribe or publish to a specific set of actors.
+ Each mailbox has its own URIs
+ URIs can be organized into APIs. For example `<guid>/request/add_device`

An actor can operate only on 3 kind of mailboxes which are:

**Request mailboxes:**
+ URIs: `<guid>/request/#`
+ to store messages asking the actor do something
+ Only authorized actors can publish messages to this mailboxes
+ Only the owning actor can subscribe to

**Response mailboxes**
+ URIs: `<guid>/response` (no sub-topic)
+ Store response messages from other actors upon request messages.
+ Each response messages must have `request` fields to refer back to associated `Request messages`

**Event mailboxes:**
+ URIs: `<guid>/event/#`
+ to store events emitted by the actor
+ Only the owning actor can publish to
+ Only authorized actors can subscribe to

### Messages
Interchanged messages are in JSON format.
Broker will intercept such messages, appending `from` fields:

**Example 1: Request & Response messages**
A requests B to add_device and B responses. Let's assume that A is authorized
*Step 1: A publishes a Request message to <B guid>/request/add_device*
```js
{
	from, // A's guid, added by the broker automatically
	id, // generated by A to trigger the associated callback
	param
}
```

*Step 2: B executes the request, replying to <A guid>/response*
```js
{
	from, // B's guid, added by Message Broker automatically
	request, // original request message
	response // key-value pairs
}
```

**Example 2: Events**
Actor Wifi can emit `connected` events to `event/connected`:
```js
{
	from, // B's guid, added by Message Broker automatically
	param // any 	
}
```

## Actor Commons
This section defines a common interface about what Actors must conform in our Actor System
- Actor must securely maintain their UUIDs & tokens which are used to connect to our brokers
- Must reponse to special requests: `<guid>/request/stop`
- Must conform `Actor life cycle`
```text
`stopped` -> `starting` -> `started` -> `stopping` --> `stopped` ...
									 -> 'stopped' (if error)
						-> `stopped` (if error)

```
- Periodically emit `Status event` via `<guid>/event/status` (every 5s). For example:
```javascript
{
	status: "status.actor.{stopped, starting, started, stopping}",
	error: "describing error (optinally if there is any)"
}
```
- An actor's response should contain the original request. For example:
```js
{
	from, // B's guid, added by Message Broker automatically
	request, // original request message
	response // key-value pairs
}
```

## Actor System
Actor system contains 3 layers and boot in order
1. Core services: Primitive services
- Validator: validate all components
- LED controllers
- Message broker: eMQTT
- Database (redis)
- ActorUp: activates all actors

2. Actors: executable programs in any programming language
**System Service Actor**
- Initializer: initialize devices in the first time
- Updater: check for any update
- Monitor: monitor actor statuses
- Broker: configure brokers (acl, authen)
- Database: database service
- Bridge: connect to the cloud (if feasible)
- Analytics
- Logger
- Auth: Authentication, uuid/token grant/remove
- Housekeeper

**Driver service actor**
- znp
- wifi
- led
- speaker
-

**Device actors**: A hardware abstraction layer
- Abstract device actors
- Triggers

**User actors**
- Any registered & authorized users
