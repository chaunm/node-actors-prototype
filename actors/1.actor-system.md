Actor System
===============

| Version | Date | Author | Description |
|-------|-------|-------|-------------|
| 1.0  | May 26th 2016 | Anh Le  | Initial release |

## 1. Actors
### 1.1 Overview
Actors are programming concepts to model entities communicate via messages.
+ Can be implemented in any programming language
+ Have their own mailboxes which are authorized topics on a message broker.
+ Can be featured by a GUID

### 1.2 Mailboxes
A mailbox (a topic) can be configured to subscribe or publish to a specific set of actors.
+ Each mailbox has its own URIs
+ URIs can be organized into APIs. For example `<guid>/request/add_device`

An actor can operate only on 3 kind of mailboxes which are:

**Request mailboxes:**
+ URIs: `<guid>/request/#`
+ to store messages asking the actor do something
+ Only authorized actors can publish messages to this mailboxes
+ Only the owning actor can subscribe to

**Response mailboxes**
+ URIs: `<guid>/response` (no sub-topic)
+ Store response messages from other actors upon request messages.
+ Each response messages must have `request` fields to refer back to associated `Request messages`

**Event mailboxes:**
+ URIs: `<guid>/event/#`
+ to store events emitted by the actor
+ Only the owning actor can publish to
+ Only authorized actors can subscribe to

### 1.3 Messages
Interchanged messages are in JSON format.
Broker will intercept such messages, appending `from` fields:

**Example 1: Request & Response messages**

A requests B to add_device and B responses. Let's assume that A is authorized

*Step 1: A publishes a Request message to <B guid>/request/add_device*

```javascript
{
	from, // A's guid, added by the broker automatically
	id, // generated by A to trigger the associated callback
	param
}
```

*Step 2: B executes the request, replying to <A guid>/response*

```javascript
{
	from, // B's guid, added by Message Broker automatically
	request, // original request message
	response // key-value pairs
}
```

**Example 2: Events**

Actor Wifi can emit `connected` events to `event/connected`:

```javascript
{
	from, // B's guid, added by Message Broker automatically
	param // any 	
}
```

## 2. Actor Commons

This section defines a common interface about what Actors must conform in our Actor System

- Actor must securely maintain their UUIDs & tokens which are used to connect to our brokers

- Must reponse to special requests: `<guid>/request/stop`

- Must conform `Actor life cycle`

```text
`stopped` -> `starting` -> `started` -> `stopping` --> `stopped` ...
									 -> 'stopped' (if error)
						-> `stopped` (if error)

```

- Periodically emit `status event` via `<guid>/event/status` (every 5s). For example:
```javascript
{
	status: "status.actor.{stopped, starting, started, stopping}",
	error: "describing error (optinally if there is any)"
}
```

- An actor's response should contain the original request. For example:
```javascript
{
	from, // B's guid, added by Message Broker automatically
	request, // original request message
	response // key-value pairs
}
```

## 3. Actor System
Actor system contains 3 layers and boot in order

1. Core services: Primitive services
- Validator: validate all components
- LED controllers
- Message broker: eMQTT
- Database (redis)
- ActorUp: activates all actors

2. Actors: executable programs in any programming language

**System Service Actor**
- Initializer: initialize devices in the first time
- Updater: check for any update
- Monitor: monitor actor statuses
- Broker: configure brokers (acl, authen)
- Database: database service
- Bridge: connect to the cloud (if feasible)
- Analytics
- Logger
- Auth: Authentication, uuid/token grant/remove
- Housekeeper

**Driver service actor**
- znp
- wifi
- led
- speaker


**Device actors**: A hardware abstraction layer
- Abstract device actors
- Triggers

**User actors**
- Any registered & authorized users
